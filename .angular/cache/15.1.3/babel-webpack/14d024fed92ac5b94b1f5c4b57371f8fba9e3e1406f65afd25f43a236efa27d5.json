{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/workspace/GitHub/MyModules/tnk-storage/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TnkStorage = void 0;\nconst public_api_1 = require(\"projects/storage/src/public-api\");\nconst user_1 = require(\"./user\");\nconst database_record_1 = require(\"./database-record\");\nconst core_1 = require(\"@angular/core\");\nconst ngx_indexed_db_1 = require(\"ngx-indexed-db\");\nconst i0 = require(\"@angular/core\");\nclass TnkStorage extends ngx_indexed_db_1.NgxIndexedDBService {\n  constructor(dbConfigTnk, platformIdTnk) {\n    super(dbConfigTnk, platformIdTnk);\n    this.dbConfigTnk = dbConfigTnk;\n    this.platformIdTnk = platformIdTnk;\n    TnkStorage['DB'] = this;\n  }\n  /**\r\n   * Get app user, this functionality is optional. If you want to use the user functionality you need to add the 'user' table in the schema.\r\n   * @returns Promise of a user if the table 'user' exists. If the user does not exist, it will create a new one and return that one.\r\n   */\n  getUser() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        if (!_this.dbConfigTnk.objectStoresMeta.map(s => s.store).includes('user')) reject(\"You need to add the 'user' table in the scema if you want to use the User entity.\");\n        _this.getAllFromTable(new user_1.User()).then(data => {\n          if (!data || !data.length) {\n            let user = new user_1.User();\n            _this.updateUser(user);\n            resolve(user);\n          } else resolve(data[0]);\n        }, error => reject(error));\n      });\n    })();\n  }\n  /**\r\n   * Update the user data.\r\n   * @param user The new user data.\r\n   */\n  updateUser(user) {\n    this.update(\"user\", (0, database_record_1.toDB)(user)).subscribe(data => console.log(\"update user:\" + data));\n  }\n  /**\r\n   * No true implementation as of now, this is in design for syncing between devices. That will be in a future release.\r\n   * @param owner\r\n   * @returns Whether the user on this device is the owner of this object.\r\n   */\n  isOwner(owner) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!owner) return true;\n      return (yield _this2.getUser()).databaseKey == owner;\n    })();\n  }\n  /**\r\n   * Inserts the given entity in the database.\r\n   * No need to call this one. Seems like 'set' works for inserting as well.\r\n   * @param entity To create\r\n   */\n  create(entity) {\n    this.add(entity.getTableName(), (0, database_record_1.toDB)(entity)).subscribe(key => console.log(\"key:\", key));\n  }\n  /**\r\n   * Supposedly inserts batch of records. Limit the number of data to under 100 if possible.\r\n   *\r\n   * Create Batch causes problems, avoid if possible, or use for small batches. Remember to subscribe to it or it will not do its job.\r\n   * In my own projects I had to stop using it and add each record individually. It was fast enough that I didn't mind.\r\n   * @param table Name of the store\r\n   * @param entities Entities to insert into DB.\r\n   * @returns Observalbe to subscribe to. If you do not subscribe it will not perfom the actions.\r\n   */\n  createBatch(table, entities) {\n    return this.bulkAdd(table, entities.map(e => (0, database_record_1.toDB)(e)));\n  }\n  /**\r\n   * Gets saved version of the entity provided from the DB.\r\n   * Can be used for reloading entities.\r\n   * @param entity Entity to reload\r\n   * @returns Promise of saved entity.\r\n   */\n  getByEntity(entity) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this3.get(entity.getTableName(), entity.databaseKey);\n    })();\n  }\n  /**\r\n   * Given a filter condition it will filter the table for entities.\r\n   * @param instance Instance of type to be returned. Is necessary to fix the list retrieved from the DB.\r\n   * @param condition Function with storage entity as parameter and boolean return. Will be used for filtering\r\n   * @param returnKeys Whether you to return the keys of the entities returned instead of the entities themselves\r\n   * @returns Either array of filtered entities or their keys.\r\n   */\n  getFiltered(instance, condition, returnKeys) {\n    var _superprop_getGetAll = () => super.getAll,\n      _this4 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const results = [];\n        _superprop_getGetAll().call(_this4, instance.getTableName()).subscribe({\n          next: data => {\n            data.forEach(d => {\n              if (condition(d.entity)) results.push(returnKeys ? d.databasekey : d.entity);\n            });\n            resolve((0, public_api_1.fixList)(instance, results));\n          },\n          error: err => reject(err)\n        });\n      });\n    })();\n  }\n  /**\r\n   * Gets all entities in the given entities table.\r\n   * @param instance The type of entities to return\r\n   * @param returnKeys Whether you to return the keys of the entities returned instead of the entities themselves\r\n   * @returns Either array of all entities of table or their keys.\r\n   */\n  getAllFromTable(instance, returnKeys) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this5.getFiltered(instance, data => true, returnKeys).then(data => resolve(data), err => reject(err));\n      });\n    })();\n  }\n  /**\r\n   * Retrieves an entity from the table provided that matches the key given.\r\n   * @param table Table name\r\n   * @param databaseKey Key of entity\r\n   * @returns Promise of the retrieved entity.\r\n   */\n  get(table, databaseKey) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.getByKey(table, databaseKey).subscribe({\n          next: data => {\n            console.log(\"data:\", data);\n            if (!data) return resolve(data);\n            return resolve(data.entity);\n          }\n        });\n      } catch (e) {\n        console.log(e);\n        reject();\n      }\n    });\n  }\n  /**\r\n   * Updates or inserts the given entity in the DB.\r\n   * @param entity Entity to update or create\r\n   * @returns Promise if you want to handle the finish of updating, however the return is just the key.\r\n   */\n  set(entity) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this6.update(entity.getTableName(), (0, database_record_1.toDB)(entity)).subscribe(key => {\n          return resolve(key);\n        });\n      });\n    })();\n  }\n  /**\r\n   * Deletes entity from DB.\r\n   * @param entity Entity to delete.\r\n   */\n  deleteEntity(entity) {\n    super.delete(entity.getTableName(), entity.databaseKey).subscribe(data => console.log(\"delete: \" + data));\n  }\n  /**\r\n   * Deletes all given keys from table.\r\n   * @param table Table name\r\n   * @param keys Keys to delete\r\n   * @returns Promise if you want to handle the finish of deletion.\r\n   */\n  deleteKeys(table, keys) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this7.bulkDelete(table, keys).subscribe(result => {\n          console.log('result: ', result);\n          return resolve(result);\n        });\n      });\n    })();\n  }\n}\nexports.TnkStorage = TnkStorage;\nTnkStorage.ɵfac = function TnkStorage_Factory(t) {\n  return new (t || TnkStorage)(i0.ɵɵinject(ngx_indexed_db_1.CONFIG_TOKEN), i0.ɵɵinject(core_1.PLATFORM_ID));\n};\nTnkStorage.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TnkStorage,\n  factory: TnkStorage.ɵfac,\n  providedIn: 'root'\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}