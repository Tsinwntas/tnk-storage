{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/workspace/GitHub/MyModules/tnk-storage/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixList = exports.EmptyEntity = exports.StorageEntity = exports.DataFactory = void 0;\nconst storage_service_1 = require(\"./storage.service\");\nconst unique_id_1 = require(\"./unique-id\");\nclass DataFactory {\n  constructor(instance, keys) {\n    this.instance = instance;\n    this.keys = keys;\n  }\n  get() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      //BAD PRACTICE BUT INJECTING THE SERVICE DOESN'T WANT TO WORK!\n      const unfinishedData = yield storage_service_1.TnkStorage['DB'].getFiltered(_this.instance.getTableName(), entity => _this.keys.includes(entity.databaseKey));\n      return fixList(_this.instance, unfinishedData);\n    })();\n  }\n}\nexports.DataFactory = DataFactory;\nclass StorageEntity {\n  constructor(toClone) {\n    if (toClone) this.deepClone(toClone);\n    if (!this.databaseKey) this.databaseKey = (0, unique_id_1.default)();\n  }\n  getTableName() {\n    return (this.instance ? \"instance\" : this.isMock ? \"mock\" : \"\") + \"\" + this.getTableNameForClass();\n  }\n  instantiate(toInstantiate) {\n    if (toInstantiate) {\n      this.deepClone(toInstantiate);\n      this.databaseKey = (0, unique_id_1.default)();\n    }\n    this.instance = true;\n    return this;\n  }\n  mock(toMock) {\n    if (toMock) {\n      this.deepClone(toMock);\n      this.databaseKey = (0, unique_id_1.default)();\n    }\n    this.isMock = true;\n    return this;\n  }\n  saveEntity() {\n    Object.keys(this).forEach(key => {\n      if (this[key] && isStorageEntity(this[key])) getAsStorageEntity(this[key]).saveEntity();else if (this.isStorageEntityArray(key) || isFunction(this[key])) this[key] = undefined;\n    });\n    return this;\n  }\n  isStorageEntityArray(key) {\n    return Array.isArray(this[key]) && this[key].length > 0 && isStorageEntity(this[key][0]);\n  }\n  isEntitiesSynced(keys, entities) {\n    if (!entities) return false;\n    return entities.length == keys.length;\n  }\n  deepClone(entity) {\n    return Object.assign(this, entity);\n  }\n  getItems(dirty, references, items) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!references || references.length == 0) return [];\n      if (!_this2.isEntitiesSynced(references, items)) {\n        items = yield new DataFactory(dirty, references).get();\n        cleanUp(references, items);\n      }\n      return items;\n    })();\n  }\n}\nexports.StorageEntity = StorageEntity;\nclass EmptyEntity extends StorageEntity {\n  getTableNameForClass() {\n    throw new Error('Method not implemented.');\n  }\n  getCleanModel() {\n    throw new Error('Method not implemented.');\n  }\n  deepClone(o) {\n    throw new Error('Method not implemented.');\n  }\n  saveEntity() {\n    throw new Error('Method not implemented.');\n  }\n}\nexports.EmptyEntity = EmptyEntity;\nfunction fixList(object, list) {\n  return list.map(o => {\n    return object.getCleanModel().deepClone(o);\n  });\n}\nexports.fixList = fixList;\nfunction cleanUp(references, items) {\n  if (!items || !items.length) return;\n  const cleanUp = [];\n  references.forEach(ref => {\n    if (items.find(i => i.databaseKey == ref) === undefined) cleanUp.push(ref);\n  });\n  cleanUp.forEach(ref => references.splice(references.findIndex(r => r == ref), 1));\n}\nfunction getAsStorageEntity(object) {\n  return object;\n}\nfunction isStorageEntity(object) {\n  return object.saveEntity !== undefined;\n}\nfunction isFunction(value) {\n  return typeof value == \"function\";\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}