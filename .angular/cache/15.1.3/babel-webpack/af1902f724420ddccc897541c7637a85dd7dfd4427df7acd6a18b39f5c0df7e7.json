{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/workspace/GitHub/MyModules/tnk-storage/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TnkStorage = void 0;\nconst user_1 = require(\"./user\");\nconst database_record_1 = require(\"./database-record\");\nconst core_1 = require(\"@angular/core\");\nconst ngx_indexed_db_1 = require(\"ngx-indexed-db\");\nconst i0 = require(\"@angular/core\");\nclass TnkStorage extends ngx_indexed_db_1.NgxIndexedDBService {\n  constructor(dbConfigTnk, platformIdTnk) {\n    super(dbConfigTnk, platformIdTnk);\n    this.dbConfigTnk = dbConfigTnk;\n    this.platformIdTnk = platformIdTnk;\n    TnkStorage['DB'] = this;\n    debugger;\n    try {\n      //then.catch doesnt get triggered for some reason.\n      this.getUser().then(data => {\n        console.log(data);\n      }, error => {\n        console.log(error);\n        this.set(new user_1.User());\n      });\n    } catch (e) {\n      console.log(\"new user in catch\");\n      this.set(new user_1.User());\n    }\n    console.log(\"db\", this['indexedDB']);\n  }\n  getUser() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this.getAllFromTable(\"user\").then(data => resolve(data[0]), error => reject(error));\n      });\n    })();\n  }\n  updateUser(user) {\n    this.update(\"user\", (0, database_record_1.toDB)(user)).subscribe(data => console.log(\"update user:\" + data));\n  }\n  isOwner(owner) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!owner) return true;\n      return (yield _this2.getUser()).databaseKey == owner;\n    })();\n  }\n  create(entity) {\n    this.add(entity.getTableName(), (0, database_record_1.toDB)(entity)).subscribe(key => console.log(\"key:\", key));\n  }\n  //Create Batch causes problems, avoid if possible, or use for small batches. Remember to subscribe to it or it will not do its job.\n  createBatch(table, entities) {\n    return this.bulkAdd(table, entities.map(e => (0, database_record_1.toDB)(e)));\n  }\n  getByEntity(entity) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this3.get(entity.getTableName(), entity.databaseKey);\n    })();\n  }\n  getFiltered(table, condition, returnKeys) {\n    var _superprop_getGetAll = () => super.getAll,\n      _this4 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        const results = [];\n        _superprop_getGetAll().call(_this4, table).subscribe({\n          next: data => {\n            data.forEach(d => {\n              if (condition(d.entity)) results.push(returnKeys ? d.databasekey : d.entity);\n            });\n            resolve(results);\n          },\n          error: err => reject(err)\n        });\n      });\n    })();\n  }\n  getAllFromTable(table, returnKeys) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this5.getFiltered(table, data => true, returnKeys).then(data => resolve(data), err => reject(err));\n      });\n    })();\n  }\n  get(table, databaseKey) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.getByKey(table, databaseKey).subscribe({\n          next: data => {\n            console.log(\"data:\", data);\n            if (!data) return resolve(data);\n            return resolve(data.entity);\n          }\n        });\n      } catch (e) {\n        console.log(e);\n        reject();\n      }\n    });\n  }\n  set(entity) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this6.getOrCreateObjectStore(entity.getTableName()).then(() => {\n          _this6.update(entity.getTableName(), (0, database_record_1.toDB)(entity)).subscribe(key => {\n            return resolve(key);\n          });\n        });\n      });\n    })();\n  }\n  deleteEntity(entity) {\n    super.delete(entity.getTableName(), entity.databaseKey).subscribe(data => console.log(\"delete: \" + data));\n  }\n  deleteKeys(table, keys) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise((resolve, reject) => {\n        _this7.bulkDelete(table, keys).subscribe(result => {\n          console.log('result: ', result);\n          return resolve(result);\n        });\n      });\n    })();\n  }\n  deleteAll(tables) {\n    tables.forEach(table => this.deleteObjectStore(table).subscribe(data => console.log(\"deleted:\", data)));\n  }\n  getOrCreateObjectStore(store) {\n    // let indexedDB =\n    // window.indexedDB ||\n    // (window as any).mozIndexedDB ||\n    // (window as any).webkitIndexedDB ||\n    // (window as any).msIndexedDB;\n    // console.log(indexedDB)\n    return new Promise((resolve, reject) => {\n      this.count(store).subscribe(peopleCount => {\n        //store exists;\n        resolve(true);\n      }, error => {\n        const storeSchema = {\n          store: store,\n          storeConfig: {\n            keyPath: 'databasekey',\n            autoIncrement: false\n          },\n          storeSchema: [{\n            name: 'databasekey',\n            keypath: 'databasekey',\n            options: {\n              unique: true\n            }\n          }, {\n            name: 'entity',\n            keypath: 'entity',\n            options: {\n              unique: false\n            }\n          }]\n        };\n        this['dbConfig'].version = this['dbConfig'].version - 1;\n        console.log(this['dbConfig']);\n        this.createObjectStore(storeSchema);\n        resolve(true);\n      });\n    });\n  }\n}\nexports.TnkStorage = TnkStorage;\nTnkStorage.ɵfac = function TnkStorage_Factory(t) {\n  return new (t || TnkStorage)(i0.ɵɵinject(ngx_indexed_db_1.CONFIG_TOKEN), i0.ɵɵinject(core_1.PLATFORM_ID));\n};\nTnkStorage.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TnkStorage,\n  factory: TnkStorage.ɵfac,\n  providedIn: 'root'\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}