{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"E:/workspace/GitHub/MyModules/tnk-storage/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fixList = exports.EmptyEntity = exports.StorageEntity = exports.DataFactory = void 0;\nconst storage_service_1 = require(\"./storage.service\");\nconst unique_id_1 = require(\"./unique-id\");\nclass DataFactory {\n  constructor(instance, keys) {\n    this.instance = instance;\n    this.keys = keys;\n  }\n  /**\r\n   * Gets all entities available for the list of keys provided.\r\n   * Uses static instance of the DB, which is a bad practice and I am willing\r\n   * to let anyone help me use the Injector.create however I was always getting the InjectorToken not provided.\r\n   * I did provide my providers in the modules so that's not it.\r\n   */\n  get() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      //BAD PRACTICE BUT INJECTING THE SERVICE DOESN'T WANT TO WORK!\n      const unfinishedData = yield storage_service_1.TnkStorage['DB'].getFiltered(_this.instance.getTableName(), entity => _this.keys.includes(entity.databaseKey));\n      return fixList(_this.instance, unfinishedData);\n    })();\n  }\n}\nexports.DataFactory = DataFactory;\n/**\r\n * Returns the open cursor event\r\n * @param storeName The name of the store to have the entries deleted\r\n * @param keyRange The key range which the cursor should be open on\r\n */\nclass StorageEntity {\n  /**\r\n   * Deep clones the loaded entity.\r\n   * @param toClone The entity that was loaded from the DB or if for some reason you want to copy an object.\r\n   * Bear in mind, if it is just for copying, it will not create a new db key.\r\n   */\n  constructor(toClone) {\n    if (toClone) this.deepClone(toClone);\n    if (!this.databaseKey) this.databaseKey = (0, unique_id_1.default)();\n  }\n  /**\r\n   * Returns the table name used for this entity.\r\n   * Takes into consideration if the entity is an instance or mock, which means it would\r\n   * be saved in another table than the rest.\r\n   */\n  getTableName() {\n    return (this.instance ? \"instance\" : this.isMock ? \"mock\" : \"\") + \"\" + this.getTableNameForClass();\n  }\n  /**\r\n   * Copies another entity if provided and marks this one as an instance.\r\n   * This means it will be saved in a table named \"instance\"+className.\r\n   * This table needs to be added in the schema in the app.module.\r\n   * @param toInstantiate The entity that we want to instantiate\r\n   */\n  instantiate(toInstantiate) {\n    if (toInstantiate) {\n      this.deepClone(toInstantiate);\n      this.databaseKey = (0, unique_id_1.default)();\n    }\n    this.instance = true;\n    return this;\n  }\n  /**\r\n   * Copies another entity if provided and marks this one as a mock object.\r\n   * This means it will be saved in a table named \"mock\"+className.\r\n   * This table needs to be added in the schema in the app.module.\r\n   * @param toMock The entity that we want to mock\r\n   */\n  mock(toMock) {\n    if (toMock) {\n      this.deepClone(toMock);\n      this.databaseKey = (0, unique_id_1.default)();\n    }\n    this.isMock = true;\n    return this;\n  }\n  /**\r\n   * Is called when being set in the database.\r\n   * If a property is a storage entity array, it will remove it to save space.\r\n   * That is why you need to have a string array with the keys of children entities.\r\n   * Also for any children storage entities that are not an array, it will perform the saveEntity\r\n   * recurrsively to prepare them for storage.\r\n   *\r\n   * You shouldn't have to ever call this, but you can extend it if you want something changed.\r\n   */\n  saveEntity() {\n    Object.keys(this).forEach(key => {\n      if (this[key] && isStorageEntity(this[key])) getAsStorageEntity(this[key]).saveEntity();else if (this.isStorageEntityArray(key) || isFunction(this[key])) this[key] = undefined;\n    });\n    return this;\n  }\n  isStorageEntityArray(key) {\n    return Array.isArray(this[key]) && this[key].length > 0 && isStorageEntity(this[key][0]);\n  }\n  isEntitiesSynced(keys, entities) {\n    if (!entities) return false;\n    return entities.length == keys.length;\n  }\n  /**\r\n   * When loading from the database, the items lose their functions so we need to call this\r\n   * in order to set them up for usage.\r\n   *\r\n   * You shouldn't have to ever call this, but you can extend it if you want something changed.\r\n   * @param entity The entity to clone.\r\n   */\n  deepClone(entity) {\n    return Object.assign(this, entity);\n  }\n  /**\r\n   * Loads the children storage entities of the given type.\r\n   * You call this only from the extended entities that you created that have children of type storage entity array.\r\n   * @param dirty The instance that will be used to figure out what type of children we are loading.\r\n   * @param references The array of database keys of the children.\r\n   * @param items The array of children to be filled.\r\n   */\n  getItems(dirty, references, items) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!references || references.length == 0) return [];\n      if (!_this2.isEntitiesSynced(references, items)) {\n        items = yield new DataFactory(dirty, references).get();\n        cleanUp(references, items);\n      }\n      return items;\n    })();\n  }\n}\nexports.StorageEntity = StorageEntity;\nclass EmptyEntity extends StorageEntity {\n  getTableNameForClass() {\n    throw new Error('Method not implemented.');\n  }\n  getCleanModel() {\n    throw new Error('Method not implemented.');\n  }\n  deepClone(o) {\n    throw new Error('Method not implemented.');\n  }\n  saveEntity() {\n    throw new Error('Method not implemented.');\n  }\n}\nexports.EmptyEntity = EmptyEntity;\n/**\r\n * Whenever you load a list from the database it needs to be passed here to be cleaned up and made ready for usage.\r\n * I am trying to figure out a way so that you will never have to call this. So far you need to. I am sorry.\r\n * @param object The type of entities in this list. Necessary for clean up because we cannot do new T()\r\n * @param keyRange The list that needs cleaning. The changes are not applied to this list but returned.\r\n */\nfunction fixList(object, list) {\n  return list.map(o => {\n    return object.getCleanModel().deepClone(o);\n  });\n}\nexports.fixList = fixList;\nfunction cleanUp(references, items) {\n  if (!items || !items.length) return;\n  const cleanUp = [];\n  references.forEach(ref => {\n    if (items.find(i => i.databaseKey == ref) === undefined) cleanUp.push(ref);\n  });\n  cleanUp.forEach(ref => references.splice(references.findIndex(r => r == ref), 1));\n}\nfunction getAsStorageEntity(object) {\n  return object;\n}\nfunction isStorageEntity(object) {\n  return object.saveEntity !== undefined;\n}\nfunction isFunction(value) {\n  return typeof value == \"function\";\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}